<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>鏡片最小直徑計算器</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f2f2f2; }
    label, input, button, select { display: block; margin: 10px auto; width: 90%; max-width: 500px; }
    canvas { display: block; margin: 20px auto; border: 1px solid #ccc; }
    #result { text-align: center; font-weight: bold; color: #0066cc; margin-top: 10px; }
  </style>
</head>
<body>

<h2>鏡片最小直徑計算器</h2>

<!-- 最小直徑計算器 -->
<label>瞳孔距離（PD，mm）<input type="number" id="pd" /></label>
<label>鏡框幾何中心距離（GC，mm）<input type="number" id="gc" /></label>
<label>偏移距離（Decentration，mm）<input type="number" id="decentration" /></label>
<label>安全邊距（Edge buffer，mm）<input type="number" id="buffer" value="2" /></label>
<button onclick="calculateMLD()">計算最小直徑</button>
<div id="mldResult">最小直徑：-- mm</div>

<!-- 圖像辨識 -->
<hr/>
<h3>鏡框圖像分析</h3>
<label>上傳鏡框圖片<input type="file" id="upload" accept="image/*"></label>
<label><input type="checkbox" id="autoDetect"> 啟用自動判讀與輪廓標記</label>
<canvas id="canvas" width="500" height="400"></canvas>
<div id="result">尚未上傳圖片</div>

<script>
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');
let img = new Image();
let cvReady = false;

cv['onRuntimeInitialized'] = () => { cvReady = true; };

document.getElementById('upload').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(evt) {
    img.onload = function() {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      if (document.getElementById('autoDetect').checked && cvReady) detectShape();
    };
    img.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});

function detectShape() {
  let src = cv.imread(canvas);
  let dst = new cv.Mat();
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
  cv.Canny(gray, dst, 50, 150);
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  if (contours.size() === 0) {
    document.getElementById('result').innerText = '未偵測到形狀';
    return;
  }

  let maxContour = contours.get(0);
  for (let i = 1; i < contours.size(); i++) {
    if (cv.contourArea(contours.get(i)) > cv.contourArea(maxContour)) {
      maxContour = contours.get(i);
    }
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0);
  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < maxContour.data32S.length / 2; i++) {
    let x = maxContour.data32S[i * 2];
    let y = maxContour.data32S[i * 2 + 1];
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.stroke();

  // 判讀形狀
  let peri = cv.arcLength(maxContour, true);
  let approx = new cv.Mat();
  cv.approxPolyDP(maxContour, approx, 0.02 * peri, true);
  let shape = '未知形狀';
  if (approx.rows === 3) shape = '三角形';
  else if (approx.rows === 4) shape = '方形';
  else if (approx.rows > 4 && approx.rows <= 6) shape = '橢圓形';
  else if (approx.rows > 6) shape = '圓形';

  document.getElementById('result').innerText = `形狀判讀結果：${shape}（頂點數 ${approx.rows}）`;

  approx.delete(); src.delete(); dst.delete(); gray.delete();
  contours.delete(); hierarchy.delete();
}

function calculateMLD() {
  const pd = parseFloat(document.getElementById('pd').value);
  const gc = parseFloat(document.getElementById('gc').value);
  const dec = parseFloat(document.getElementById('decentration').value);
  const buffer = parseFloat(document.getElementById('buffer').value);
  if (isNaN(pd) || isNaN(gc) || isNaN(dec) || isNaN(buffer)) {
    document.getElementById('mldResult').innerText = '請完整輸入所有數值';
    return;
  }
  const mld = Math.round((Math.abs(pd - gc) + dec + buffer) * 2 * 10) / 10;
  document.getElementById('mldResult').innerText = `最小直徑建議值：${mld} mm`;
}
</script>

</body>
</html>